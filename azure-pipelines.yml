# azure-pipelines.yml

trigger:
  branches:
    include:
      - main

stages:
- stage: Deploy
  displayName: Deploy WellTrajectoryAI to Hamster
  jobs:
  - deployment: DeployToHamster
    displayName: 'Deploy WellTrajectoryAI to Hamster'
    pool:
      name: ULH-Self-Hosted
      demands:
        - Agent.Name -equals UlhChatHampster
        - Agent.OS -equals Linux
    environment: 'UlhChatHampster'

    strategy:
      runOnce:
        deploy:
          steps:
          - checkout: self

          # Sanity / debug info so you can see what agent you're on and what files it pulled
          - bash: |
              echo "Agent name (should match UlhChatHampster): $(Agent.Name)"
              echo "Running as user (should be deploy): $(whoami)"
              echo "Sources directory: $(Build.SourcesDirectory)"
              echo "Repo top-level contents:"
              ls -la "$(Build.SourcesDirectory)"
            displayName: 'Sanity: agent & repo'

          # Sync the entire repo into /opt/welltrajectoryai on the Hamster box
          # This overwrites that folder so it always matches the latest commit from main.
          - bash: |
              set -euo pipefail
              SRC_ROOT="$(Build.SourcesDirectory)"
              DEST="/opt/welltrajectoryai"

              echo "Syncing repo to $DEST"
              rsync -a --delete "$SRC_ROOT"/ "$DEST"/

              # Lock down secrets in .env on the server
              if [ -f "$DEST/.env" ]; then
                chmod 640 "$DEST/.env"
              fi

              echo "Contents of $DEST after sync:"
              ls -R "$DEST" | head -200
            displayName: "Sync code to /opt/welltrajectoryai"

          # Build and (re)start the container using docker compose up --build
          # We do this directly instead of relying on systemctl to do it,
          # because we want to make sure we're building from the code we JUST synced.
          - bash: |
              set -exuo pipefail

              # Rootless Docker environment for user 'deploy'
              export XDG_RUNTIME_DIR="/run/user/$(id -u)"
              export DOCKER_HOST="unix://$XDG_RUNTIME_DIR/docker.sock"

              cd /opt/welltrajectoryai

              echo "Running docker compose up -d --build ..."
              docker compose up -d --build

              echo "Currently running containers:"
              docker ps
            displayName: "Compose up with build"

          # Health check the app on localhost:8050
          # Your docker-compose.yml maps container port 8050 -> host 127.0.0.1:8050
          # Your app.py MUST bind to host='0.0.0.0' and port=8050 for this to pass.
          - bash: |
              echo "Checking if app is alive..."
              for i in {1..30}; do
                if curl -f http://127.0.0.1:8050/ > /dev/null 2>&1; then
                  echo "✅ Application is responding on port 8050"
                  echo "✅ Ready for Caddy reverse proxy / subdomain"
                  exit 0
                fi
                echo "Attempt $i/30 - waiting..."
                sleep 10
              done

              echo "❌ App did not start within 5 minutes"
              echo "Dumping docker ps for debugging:"
              export XDG_RUNTIME_DIR="/run/user/$(id -u)"
              export DOCKER_HOST="unix://$XDG_RUNTIME_DIR/docker.sock"
              docker ps || true
              exit 1
            displayName: 'Health check'
